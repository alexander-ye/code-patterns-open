---
problem_number: 1356
title: Sort Integers by The Number of 1 Bits
src:
  {
    domain: LeetCode,
    url: https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/,
    difficulty: "Easy",
  }
languages: [Python]
author: Alex Ye
---

## Problem Statement

<blockquote src={frontmatter.src_url}>

You are given an integer array `arr`. Sort the integers in the array in ascending order by the number of `1`'s in their binary representation and in case of two or more integers have the same number of `1`'s you have to sort them in ascending order.

Return _the array after sorting it_.

**Constraints**

- `1 <= arr.length <= 500`
- <code>
    0 {"<="} arr[i] {"<="} 10<sup>4</sup>
  </code>

<details>
<summary><strong>Example Test Cases</strong></summary>

**Example 1:**

```
Input: arr = [0,1,2,3,4,5,6,7,8]
Output: [0,1,2,4,8,3,5,6,7]
Explantion: [0] is the only integer with 0 bits.
[1,2,4,8] all have 1 bit.
[3,5,6] have 2 bits.
[7] has 3 bits.
The sorted array by bits is [0,1,2,4,8,3,5,6,7]
```

**Example 2:**

```
Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
Output: [1,2,4,8,16,32,64,128,256,512,1024]
Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
```

</details>
</blockquote>

## Solution

The element in the middle is guaranteed to be the answer---by definition of majority.

```python
def countOnesInBinary(number: str) -> int:
  # Count number of 1's in number's binary representation
  binary_ones = bin(number).count('1')
  # Return tuple (number of ones in binary, original number)
  return (binary_ones, number)

class Solution:
  def sortByBits(self, arr: List[int]) -> List[int]:
    # key function for sorted considers (first comparison, tiebreaker)
    return sorted(arr, key=countOnesInBinary)
    #arr.sort(key=self.countOnesInBinary)
    #return arr
```
